一、	Java简介
Java平台的三个版本：标准版SE、企业版EE、移动版ME。
Java的主要特点：面向对象、分布式、可移植、多态性。优势主要集中在设计类和功能接口方面。Java程序支持多线程技术。
Java程序中的任意一个类都有main方法(即主函数入口)。
System.out.println则是打印操作。
Java的类名应和文件名相同。
Java是区分大小写的。


二、	基本数据类型
整型的数值范围：byte_1、short_2、int_3、long_4。
八进制表示：0字开头；十六进制：0x或0X开头。
浮点型：单精度(4)时要加尾缀f或F；双精度(8)时要加尾缀d或D。
字符型：占有2byte——转义字符同C语言。
布尔型：有真值true和假值false。
数据类型之间的转换：自动转换、强制转换、隐含转换。
标识符的命名规则：只能含英文字母A~Z、a~z(以此开头)，数字1~9及符号“_”和“$”。
Java标识符对大小写是敏感的。
 
 
PS:关键字都是小写的。
行注释：//		块注释：/*……*/

三、	运算符
算术运算符、自增自减符、关系运算符、逻辑运算符、三元运算符、位运算符、位移运算符、赋值运算符。
算术运算符：“+”、“-”、“*”、“/”、“%”。
自增自减符：“++”、“--”。置前则先自增减再自运算，之后则先运算再自增减。
关系运算符：“==”、“！=”、“>=”、“<=”、“>”、“<”。
逻辑运算符：“&&”、“||”、“!”(PS:注意逻辑短路)。
三元运算符：(condition) ? True : false;
位运算符：按位与“&”、按位或“|”、按位异或“^”
位移运算符：右移“>>”、左移“<<”、无符号右移“>>>”。PS:无符号则会把符号位与进行运算。
赋值运算符：“=”；“+=”、”“-=”、“*=”、“/=”、“%=”、“^=”、“|=”、“&=”、“>>=”、“<<=”、“>>>=”。
优先级：
 
 
PS：注意位运算符和位移运算符。

四、	流程控制
总共有：if条件语句、switch分支语句、while循环语句、do-while循环语句、for循环语句。
if条件语句：if (expression) {methods_01} else {methods_02}
switch分支语句：switch (expression) { case expression1 { methods_01; break; } …… default {methods} }
while循环语句：while (expression) { methods }
do-while循环语句：do { methods } while (expression)
for循环语句：for ( initialize variable; expression; cycle methods )
中断与继续执行：break 和 continue 
Break：结束循环，退出。
Continue：提前结束本轮循环，进行下一轮。

五、	数组
创建数组的默认初值：
 
PS:布尔型默认值是false(0)。
使用new来新建数组：int[] a = new {a0,a1……an}；
循环初始化。
问题：可以在创建数组时用变量来规定长度吗？
排序：使用array.sort方法。


六、	类与对象
面向对象方法：将成员变量和方法隐藏在对象中，并且让所有的访问都只能通过对象间的借口进行。
面向对象的特点：抽象、封装、继承、多态。
抽象是指在定义类时，确定该类的行为和动作。
封装是指限制外界对类的成员变量及方法进行的访问的。
继承是发生在父类和子类间的、用于共享父类的成员变量和方法的一种模式。
多态是指对象在编译期和运行期具有的两种状态。
定义类：class name { variables; functions; }
在主入口方法中创建类的实例：new class_name ();
一个完整的类应含有主入口方法。
在同一目录下使用类，直接使用就好；在不同目录下使用类，则须使用import语句，引用不同目录下的类(目录即是包)。
局部变量：在方法体中定义和起作用的变量，外界无法访问。与成员变量，若在方法体中定义变量时未赋初值，则系统不会为之赋值。
成员变量可以被修饰符public、protected、private、static、default、final修饰；局部变量只能被final修饰。
Final修饰符表示该对象不可以再拥有子类。
This 只能在方法中使用，且该方法不能有static修饰。
定义方法:
修饰符 返回类型 名称 (参数) {方法体}
方法的默认修饰符为public。
只有当方法中的返回类型为class时，其返回值才能为NULL。
JDK中预定义的类：
1.系统时间——Data类：import java.util.Data;
2.基本数据类型——Integer类。

七、	控制逻辑
为了便于管理不同的类类型需要建立包(package)来实现目录的功能。
Package是JDK中的关键字，其定义语句只能出现在源文件的最前方！并且在一个源文件中最多只能有一个，因为一个类只能出现在一个包之中。对于多层的包需要用“.”号来进行分离。
若要使用包中的类，则需引进该包。使用关键字import，其格式如下：
Import package_name·class_name；
若要导入该包中的静态成员成员和方法，则需使用static关键字，其格式如下：
Import static package_name·class_name；
与C++类似，Java同样具有public、protected、private这三个访问级别。但与之不同的的是，Java中类的默认访问级别与C++中的略有不同。那就是采取默认访问级别的类只能被同一个包中的类所访问，而其他包中的类是不允许访问它的。
最终修饰符final：被final修饰的原始类型一经初始化就不可以再为其赋值；被final修饰的引用类型一经初始化就不可以再指向其他对象。此外，再进行赋值之前，系统是不会为这些成员默认初始化的。
静态修饰符static：被static修饰过的成员是属于类而非对象的，也就是说该类的对象可以共享该static变量。当任一对象访问静态成员时，保存在类的公共存储单元中的值也会被改变。而对于使用static修饰的方法而言，其中的操作必须是针对静态成员进行的，且不得使用this关键字。

八、	继承
在Java中定义子类时需要使用关键字extend。调用子类时，若子类的构造器没有指定使用父类的哪个构造接口，则默认使用父类的无参数构造器。可以通过在子类的构造器重使用super方法来指定父类中的构造器。
与C++不同，Java中的子类只能继承自一个父类，而父类则可以同时拥有多个子类。
由protected修饰的成员变量可被同一个包里面的其他类所访问，而对于不同包中的类，只有子类才能访问它。
子类可以通过定义自己的成员变量来覆盖父类的变量。
而针对方法，子类若是重写了拥有相同名称和参数的方法，则一般情况下，调用子类时使用的是重写后的方法，而对于父类中使用static修饰过的方法，则无法重写。
所谓重载，是指存在多个拥有不同参数、相同名称的方法。而这些方法的返回值可以相同也可以不同。在实例中执行那种方法，则取决于输入的参数列表。
注意：静态的方法是不能被重载的。
Java中的abstract关键字相当于C++中的virtual。有abstract定义抽象方法相当于由virtual定义的虚函数。只能由子类来重写。
枚举类enumeration相当于一组封装好的成员变量。
在Java中try{} catch{}语句块可以处理异常。即当try语句块中的语句通过时，正常执行，若是出了问题，交由catch来处理异常。

九、	接口
定义接口的关键字为interface，使用接口的关键字为implement，举例如下：
Public interface aaa
{ ; } //创建接口的成员变量(默认为常量)和方法
Public class user implement aaa
{ ; } //创建类的成员变量和方法
抽象类和接口类似，其中的方法均为抽象方法，即没有方法体的方法。二者均不能实例化，因为它们只是为了继承使用的。
注：若父类拥有抽象方法，则父类必为抽象类。另外，抽象类允许有普通方法。
判断类型关键字instanceof是二元操作符，使用格式为：
对象的引用 instanceof 类或接口;
使用instanceof可以判断对象的引用与类或接口是否一致，从而返回boolean值。


十、	构造器
在类中定义构造器的指令格式：
访问级别修饰符 类的名称(参数列表)
构造器的名称需与类的名称相同!且构造器可以拥有不同的参数列表来实现重载。
构造器不能有返回值，void也不行。
默认定义的访问级别为default。由public修饰的构造器可以被任意类访问到，而由private修饰的构造器则只能由本类调用。但是不能有final、static之类的修饰。重载构造器时的修饰符只能有public、protected、private三个。
构造器是为了创立一个类的对象实例而出现的。
在不同包下用import引进所需要的类后，就可以使用其中的类的构造器了。子类可以调用父类的构造器。但是子类不能继承父类的构造器！
如果声明了有参构造器，那么系统就不会自动生成默认的无参构造器。也就是说，如果只定义了有参构造器，但却要执行无参构造器的语句，则编译时系统会报错。
单子模式：即用private修饰构造器，并定义可返回对象引用的public方法，借此来让别的类对象使用该对象的引用。

十一、	异常处理
使用try-catch语句块进行异常处理。Try语句块主要用于可能会出现异常的区域，其后可以跟多个catch语句块，catch语句块中主要是针对不同的异常情形提供相应的处理方法。基本用法如下：
Try { /*可能出现异常的代码*/ }
Catch ( Exception e )
{ /*发生异常时的处理代码*/ }
在程序中如果没有使用try-catch语句块，则当发生异常时，程序会自动退出运行。而在使用之后，程序则不会自动退出。
有的代码无论程序是否发生异常都必须得到执行，则应将其放入finally语句块中。，示例如下：
Finally { /*肯定被执行的代码*/ }
执行catch语句块时，是按照编写的先后顺序来判断的，符合异常描述的前方语句将率先得到执行。而且异常处理仅执行一次。因此，判断条件为较小的异常子集的catch语句块应当置于前方。举例：ArrayIndexOutOfBoundsException是Exception的子类，则应置前。Expectation相关的catch语句块则置后。
try语句开之后必须紧跟上catch或finally，如果一个也没有，则不会通过编译。另外，在try和catch之间，catch和finally之间不得含有其他语句。
异常的分类：总体上可分为可捕获异常与未捕获异常。所有的异常类都继承自Java类库中的Throwable类。Error类与Exception类为Throwable类的直接子类。Error是未捕获异常。Exception类中有一个RuntimeException的子类。除去RuntimeException类的直接或间接子类，Exception类的全部直接或间接子类均为捕获异常。
捕获异常通常是由外界引起的，比如输入不合法。捕获异常是程序必须处理的异常。如果try中的语句块不可能出现捕获异常，而仍然保留捕获异常处理语句，则系统会报错。
未捕获异常是可以不进行处理，这样可以通过编译，但是在运行时则会出错。其中，Error和它的子类通常是有硬件问题所导致的错误，而RuntimeException则是在运行时产生的错误。
当某一程序段出现异常时，如果自己不能进行异常处理，就可以把异常抛给上一层。如果仍然不能解决则继续上传，直到抛给main方法。如果仍然不能解决，则程序会自动中断。
可以使用throw、throws来抛出异常。示例如下：
Public static void main ( String args[] ) throws IOException
{
	Try { /*可能出现异常的代码*/ }
Catch ( IOException e )
{ throw e; }
}
自定义的异常类都需继承自Exception类：
Class 类名 extends Exception { /*类体*/ }

十二、	内部类
在外部类中创建内部类的方法和创建正常的类是一样的。内部类的使用和任何的成员变量一样，private修饰的内部类可以由外部类自由的访问，但是非外部类则不能直接访问。但在内部类中访问外部类时，如果外部类的成员变量有和内部类同名的，则默认情形下指的是内部类的成员。如果要让内部类访问同名的外部类成员，则需要this指针专门指出是外部类的成员。
局部内部类可在方法中创立。局部内部类可以直接调用外部类的成员变量，但是不可以访问外部类的局部变量(即使是同一局部中的)，除非该局部变量使用final修饰。
在静态方法中创立的局部内部类只能访问外部类的静态成员，而无法访问非静态成员。但外部类的成员访问静态方法中的局部内部类还是一样的。
在外部类中创建静态内部类的方法和创建正常的静态类是一样的。而外部类成员在访问静态内部类时是不需要创建外部类对象的，直接调用静态内部类的构造器即可，此外，还需指明该静态内部类是属于哪个外部类的。
在创建匿名内部类的同时必须创立相应的对象，并加以初始化。

十三、	多线程
线程可以通过继承Tread类来创建：
Public class 线程 extends Tread { public void run () {} }
此外，还可以通过应用Runnable接口来定义线程：
Public class 线程 implements Runnable { public void run () {} }
使用由继承Tread类得到的线程类来创建线程对象就像创建普通的类对象一样。但是要想用Runnable接口定义的线程类来创建线程对象，就必须借助于Tread类。若是直接使用之前所定义的类来创建对象，得到的只能是普通的类对象，而非线程对象。使用方法如下：
Xiancheng_Runnable xc = new Xiancheng_Runnable();
Tread t = new Tread(xc);  t.start();
启动线程需使用start关键字(这是Tread类中的一种方法)。一个线程对象只能启动一次，否则会出现异常。
